/*******************************************************************************
 *   Description:   See class declaration below
 *
 ******************************************************************************/

#ifndef _BT_REQHANDLER_H
#define _BT_REQHANDLER_H

/*******************************************************************************
 * INCLUDED FILES
 ******************************************************************************/

#include <QString>
#include <QJSValue>
#include <QVariantMap>

#include <memory>


class QJSEngine;

namespace BTCore {
    class ScriptFactory;
    class ByteArrReadWrite;
}

/*******************************************************************************
 * CLASS DECLARATION
 ******************************************************************************/

namespace BTCore {
    class ReqHandler;
}

/**
 * Class that represents single handler of the incoming message (request).
 * The handler's behavior is defined by JavaScript code.
 *
 * TODO: explain handler's JavaScript API
 */
class BTCore::ReqHandler : public QObject
{
Q_OBJECT
    /****************************************************************************
     * TYPES
     ***************************************************************************/
public:

    /**
     * Handling result
     */
    enum class Result {
        /** Should never be returned: the result is unknown.
         */
        UNKNOWN,
        /** There were no errors during execution of handler, and the request
         * was not handled by this particular handler.
         */
        OK_NOT_HANDLED,
        /** There were no errors during execution of handler, and the request
         * was handled by this handler. So, the caller should get generated
         * response from this handler, encode it, and send it on the wire (if
         * it is not empty)
         */
        OK_HANDLED,

        /** There was some JavaScript error during execution of this handler.
         * Consult `getLastError()` function to get more
         * specific error.
         */
        ERROR,
    };

    /**
     * Kind of error, when `#Result` is `Result::ERROR`
     */
    enum class Error {
        /** Unknown error: this code is returned if the handling result was not
         * `Result::ERROR`.
         */
        UNKNOWN,

        /** The given JavaScript evaluates to some non-function value.
         */
        SCRIPT_IS_NOT_FUNCTION,

        /** Exception has happened during JavaScript code execution.  Consult
         * `#getLastExceptionDetails()` function to get
         * details of the exception.
         */
        EXCEPTION,
    };

    /****************************************************************************
     * CONSTRUCTOR, DESTRUCTOR
     ***************************************************************************/
public:

    /**
     * Construct request handler with all the necessary data specified
     *
     * @param title
     *      human-readable title of the handler
     * @param p_engine
     *      JavaScript engine to use
     * @param p_script_factory
     *      Factory to use by scripts (see `#BTCore::ScriptFactory`)
     * @param script_func_code
     *      JavaScript code to execute as a handler
     */
    ReqHandler(
            QString title,
            std::shared_ptr<QJSEngine> p_engine,
            std::shared_ptr<ScriptFactory> p_script_factory,
            QString script_func_code
            );

    /**
     * Construct request handler without JavaScript engine and factory specified.
     * These should be set later by calling `setQJSEngine()`
     * and `setScriptFactory()`.
     *
     * @param title
     *      human-readable title of the handler
     * @param script_func_code
     *      JavaScript code to execute as a handler
     */
    ReqHandler(
            QString title,
            QString script_func_code = ""
            );

    /**
     * Construct request handler with default title "Untitled handler" and
     * script draft. JavaScript engine and factory should be set later by
     * calling `setQJSEngine()` and `setScriptFactory()`
     */
    ReqHandler();

    /****************************************************************************
     * PRIVATE DATA
     ***************************************************************************/
private:

    //-- human-readable handler title
    QString title;

    //-- JavaScript engine
    std::shared_ptr<QJSEngine> p_engine;
    //-- factory that is used by scripts
    std::shared_ptr<ScriptFactory> p_script_factory;

    //-- JavaScript handler code
    QString script_func_code;

    //-- Error that happened during last call of
    //   `#handle()`. Valid if only `handle()` returned
    //   `#Result::ERROR`.
    Error last_error;

    //-- Response that was generated by handler during last call of
    //   `#handle()`. Valid if only `handle()` returned
    //   `Result::OK_HANDLED`. May be nullptr, if no
    //   response is needed to send.
    std::shared_ptr<ByteArrReadWrite> p_response;

    //-- Details of exception that has happened during last call of
    //   `#handle()`. Valid if only `handle()` returned
    //   `Result::ERROR`, and `last_error` is `EXCEPTION`.
    QVariantMap last_exception_details;


    /****************************************************************************
     * STATIC METHODS
     ***************************************************************************/

    /****************************************************************************
     * METHODS
     ***************************************************************************/
public:

    /**
     * Set JavaScript engine to use
     */
    void setQJSEngine(std::shared_ptr<QJSEngine> p_engine);

    /**
     * Set script factory to use by scripts. See `#BTCore::ScriptFactory`
     */
    void setScriptFactory(std::shared_ptr<ScriptFactory> p_script_factory);

    /**
     * Get human-readable title of the handler
     */
    QString getTitle() const;

    /**
     * Set human-readable title of the handler
     */
    void setTitle(const QString &title);

    /**
     * Get JavaScript handler code
     */
    QString getScript() const;

    /**
     * Set JavaScript handler code
     *
     * TODO: explain handler's JavaScript API
     */
    void setScript(QString script_func_code);

    /**
     * Handle the request.
     *
     * @param input_msg_jsval
     *      JavaScript object that represents input data.  This object should
     *      have property "byteArr", which should be set to
     *      `BTCore::ByteArrRead` instance (of course, wrapped into `QJSValue`
     *      object).
     *
     *      It may also have some other codec-specific properties, so that
     *      handlers have access to them.
     *
     * @param script_ctx_jsval
     *      Scripts context. All handler JavaScript functions are called with
     *      `this` set to this object. This context is preserved across
     *      different message handling and all handlers, so, we can use it for
     *      information exchange between handlers.
     *
     *      Initially, this context is just an empty JavaScript object.
     *      The way it is used is completely up to the handlers.
     */
    Result handle(
            QJSValue input_msg_jsval,
            QJSValue script_ctx_jsval
            );

    /**
     * Error that happened during last call of `handle()`.
     * Valid if only `handle()` returned `Result::ERROR`.
     */
    Error getLastError();

    /**
     * Details of exception that has happened during last call of
     * `handle()`. Valid if only `handle()` returned
     * `Result::ERROR`, and
     * `getLastError()` returned
     * `Error::EXCEPTION`.
     */
    QVariantMap getLastExceptionDetails();

    /**
     * If latest `handle()` call returned
     * `Result::OK_HANDLED`, then this method returns
     * response that was generated by the handler script.
     */
    std::shared_ptr<const std::vector<uint8_t>> getResponse();


    /****************************************************************************
     * SIGNALS, SLOTS
     ***************************************************************************/

signals:

    /**
     * Emitted when human-readable title has changed by calling
     * `setTitle()`.
     */
    void titleChanged(const QString &title);

};


#endif // _BT_REQHANDLER_H
